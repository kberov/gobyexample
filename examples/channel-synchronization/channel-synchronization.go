// Можем да ползваме канали, за да съгласуваме[^synchro]
// изпълнението на различни гозадачи. Тук имаме пример с
// получаване на данни, което спира изпълнението на цялата
// програма, изчаквайки я да приключи.[^blocking_rcv]
// Когато изчаквате множество гозадачи да приключат, може
// да предпочетете да използвате можествено изчакване. То
// е осъществено чрез структурата
// [`WaitGroup`](waitgroups) в пакета `sync`.
// [^blocking_rcv]: blocking receive – блокиращо получаване
// [^synchro]: synchronization – съгласуване
package main

import (
	"fmt"
	"time"
)

// Това е функцията, която ще изпълним в гозадача. Канала
// `готово` ще използваме, за да уведомим друга
// гозадача (програмата ни), че тази функция е приключила.
func работник(готово chan bool) {
	fmt.Print("работя...")
	time.Sleep(time.Second)
	fmt.Println("готово")

	// Изпращаме стойност като съобщение, че сме готови.
	готово <- true
}

func main() {

	// Пускаме гозадачата `работник` и ѝ подаваме канала,
	// по който да изпрати съобщението.
	готово := make(chan bool, 1)
	go работник(готово)

	// Изпълнението спира и чака, докато получи съобщение
	// от работника по канала.
	<-готово
}
