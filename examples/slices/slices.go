// _Отрязъците_[^slice] са важен вид данни в Go и дават
// възможност за по-мощно взаимодействие с
// последователности от поредиците.
// [^slice]: slice – отрязък

package main

import (
	"fmt"
	"slices"
)

func main() {

	// За разлика от поредиците, вида на отрязъците зависи
	// само от вида на членовете, които съдържат, не и от
	// броя им. Неначенат отрязък има стойнот `nil` и
	// дължина 0.
	var s []string
	fmt.Println("неначенат:", s, s == nil, len(s) == 0)

	// За да създадете отрязък със зададена дължина,
	// използвайте вградената функция `make` (правя). Тук
	// правим отрязък от низове с дължина 3 (иначе с
	// нулева дължина). По подразбиране
	// вместимостта[^capacity] на новосъздаден отрязък е
	// равна на дължината му. Ако предварително знаем, че
	// дължината на отрязъка ще расте, можем да подадем на
	// `make` изрично и вместимост.
	// [^capacity]: capacity – вместимост, капацитет
	s = make([]string, 3)
	fmt.Println(
		"празен:", s, "len:", len(s), "cap:", cap(s))

	// Можем да задаваме и взимаме стойности, точно като
	// при поредиците.
	s[0] = "a"
	s[1] = "b"
	s[2] = "c"
	fmt.Println("задаваме:", s)
	fmt.Println("взимаме:", s[2])

	// `len` връща дължината на отрязъка, както се очаква.
	fmt.Println("len:", len(s))

	// Освен основните действия, отрязъците поддържат още
	// няколко, което ги прави по-богати от поредиците.
	// Едно от тях е вградената функция `append`, която
	// връща нов отрязък, съдържащ една или повече нови
	// стойности. Забележете, че трябва да приемем
	// върнатата стойност от `append`, понеже можем да
	// получим нов отрязък.
	s = append(s, "d")
	s = append(s, "e", "f")
	fmt.Println("добавено:", s)

	// Отрязъците могат също да бъдат копирани. Тук
	// създаваме празен отрязък `c` със същата дължина
	// като на `s` и копираме всичко от `s` в `c`.
	c := make([]string, len(s))
	copy(c, s)
	fmt.Println("copy:", c)

	// Отрязъците поддържат действие от вида
	// `отрязък[отпоказалец:додължина]`. Например
	// написаното по следния начин ни връща отрязък,
	// съдържащ членовете `s[2]`, `s[3]`, и `s[4]`.
	l := s[2:5]
	fmt.Println("sl1:", l)

	// Следното действие отрязва всички членове от
	// началото до 5ти (но без него).
	l = s[:5]
	fmt.Println("sl2:", l)

	// А написано по следния начин, връща отрязък,
	// съдържащ всички членове от и включително 2ри до
	// края.
	l = s[2:]
	fmt.Println("sl3:", l)

	// Също така можем едновременно да обявим и наченем
	// отрязък.
	t := []string{"g", "h", "i"}
	fmt.Println("обявление:", t)

	// Пакетът `slices` съдържа набор от полезни функции
	// за отрязъци.
	t2 := []string{"g", "h", "i"}
	if slices.Equal(t, t2) {
		fmt.Println("t == t2")
	}

	// Можем да създаваме многомерни структури от
	// отрязъци. Дължината на вътрешния отрязък, за
	// разлика от поредиците, може да бъде различна за
	// всеки отделен отрязък.
	twoD := make([][]int, 3)
	for i := range 3 {
		innerLen := i + 1
		twoD[i] = make([]int, innerLen)
		for j := range innerLen {
			twoD[i][j] = i + j
		}
	}
	fmt.Println("2d: ", twoD)
}
