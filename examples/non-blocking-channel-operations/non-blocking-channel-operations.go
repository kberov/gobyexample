// Изпращането по канал и получаването по канал по
// подразбиране спира (блокира) главната нишка на
// изпълнението. Въпреки това можем да използваме `select`
// с допълнителна клауза – `default`[^default], за да
// осъществим _невъзпиращи (неблокиращи)_ изпращания,
// получавания и дори неблокиращи _множествени избори_[^multiway].
// [^default]: default – стойност (в случая – избор) по подразбиране
// [^multiway]: multi-way select - множествен избор за действие с канал – избор от повече канали, но не задължително с разлчни посоки на действията – получаване и изпращане.

package main

import "fmt"

func main() {
	писма := make(chan string)
	сигнали := make(chan bool)

	// Ето едно неблокиращо получаване. Ако в канала `писма` вече има стойност, тогава `select` ще влезе в случая `<-писма` и ще вземе тази стойност. Иначе ще влезе в подразбирания случай `default`.
	select {
	case писмо := <-писма:
		fmt.Println("получено писмо:", писмо)
	default:
		fmt.Println("няма нови писма")
	}

	// Неблокиращото изпращане работи по подобен начин.
	// Тук `писмо` не може да бъде изпратено по канала
	// `писма`, защото каналът няма зададена вместимост
	// (значи не задържа) и няма получател. Затова бива
	// избран случаят `default`.
	писмо := "hi"
	select {
	case писма <- писмо:
		fmt.Println("изпратено писмо", писмо)
	default:
		fmt.Println("не е изпратено писмо")
	}

	// Можем да имаме повече случаи над случая по
	// подразбиране `default` и така да осъществим
	// множествен неблокиращ избор. Тук осъществяваме
	// неблокиращ избор от каналите `писма` и `сигнали`.
	select {
	case писмо := <-писма:
		fmt.Println("получено писмо", писмо)
	case sig := <-сигнали:
		fmt.Println("получен сигнал", sig)
	default:
		fmt.Println("бездействие")
	}
}
