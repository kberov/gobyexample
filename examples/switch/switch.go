// Изявленията от вида _switch_ (превключване) изразяват
// условия с множество разклонения.

package main

import (
	"fmt"
	"time"
)

func main() {

	// Ето просто изявление `switch`.
	i := 2
	fmt.Print("Пишем ", i, " като ")
	switch i {
	case 1:
		fmt.Println("едно")
	case 2:
		fmt.Println("две")
	case 3:
		fmt.Println("три")
	}

	// Може да ползвате запетаи, за да разделите множество
	// изрази в едно и също изявление за случай – `case`.
	// В този пример ползваме и незадължителния случай
	// `default` (когато не попаднем в нито един от
	// изброените преди това случаи).
	switch time.Now().Weekday() {
	case time.Saturday, time.Sunday:
		fmt.Println("Почивен ден е.")
	default:
		fmt.Println("Работен ден е.")
	}

	// `switch` без израз  е друг начин да извършваме
	// логически действия както при if/else. Тук също
	// показваме, че изразите `case` може и да не са
	// непроменливи (константи).
	t := time.Now()
	switch {
	case t.Hour() < 12:
		fmt.Println("Преди обяд е.")
	default:
		fmt.Println("След обяд е.")
	}

	// `switch` (превключване) между типове сравнява
	// типовете на променливите вместо техните стойности.
	// Можете да ползвате този подход, за да откриете типа
	// на стойност за взаимодействие (интерфейс). В този
	// пример променливата `t` ще има тип, съответстващ на
	// типа на подадената на функцията стойност.
	каквоСъмАз := func(i interface{}) {
		switch t := i.(type) {
		case bool:
			fmt.Println("Аз съм булева стойност – bool.")
		case int:
			fmt.Println("Аз съм цяло число – int.")
		default:
			fmt.Printf("Непознат тип – %T\n", t)
		}
	}
	каквоСъмАз(true)
	каквоСъмАз(1)
	каквоСъмАз("Ей!")
}
