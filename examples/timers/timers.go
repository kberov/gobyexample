// Често искаме да изпълним код на Го някъде в бъдещето
// или да го изпълняваме повторно през определено време.
// Вградените възможности в Го за осъществяване на
// срочници[^timer] и часовници[^ticker] правят и двете
// задачи лесни. Първо ще разгледаме срочниците, а после
// часовниците.
// [^timer]: timer – срочник (брояч за оставащо време – срок), хронометър, таймер. Чрез срочника задаваме [краен срок](timeouts) за сбъдване на събитие.
// [^ticker]: ticker – (в разговорната реч) часовник, махало, времемер

package main

import (
	"fmt"
	"time"
)

func main() {

	// Срочниците отчитат оставащото време до единично
	// събитие в бъдещето – задават срок. Казвате на
	// срочника колко време искате да чакате и той ви дава
	// канал, по който ще се изпрати съобщение, като му
	// дойде времето. Този срочник ще чака две секунди.
	срочник1 := time.NewTimer(2 * time.Second)

	// Изразът `<-timer1.C` възпира програмата чрез своя
	// канал `C` докато изпрати стойност, означаваща
	// настъпването на срока.
	<-срочник1.C
	fmt.Println("`срочник1` звънна.")

	// Ако просто искахте да изчакате определено време,
	// можехте да използвате `time.Sleep`. Онователна
	// причина да използвате срочник, е че можете да
	// отмените настъпването на събитието (изтичането на зададения срок),
	// преди да се случи. Ето един такъв пример.
	срочник2 := time.NewTimer(time.Second)
	go func() {
		<-срочник2.C
		fmt.Println("Пуснахме срочник2.")
	}()
	stop2 := срочник2.Stop()
	if stop2 {
		fmt.Println("Спряхме срочник2.")
	}

	// Даваме на `срочник2` достатъчно време, да отброи
	// времето до събитието, ако изобщо е щял да го
	// направи. Така показваме, че всъщност е бил
	// прекъснат (спрян).
	time.Sleep(2 * time.Second)
}
